# Module_2 содержит 3 программы на тему базовых структур данных

***

# Задача про косое дерево

Реализуйте косое дерево (splay tree).

Реализация самой структуры данных должна быть инкапсулирована, т.е не зависеть от форматов входных/выходных данных и
непосредственно ввода/вывода.

Тесты предполагают "левостороннюю" реализацию, т.е если действие можно реализовать двумя симметричными способами, надо
делать тот, который больше использует левую сторону.

## Формат входных данных

На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Каждая строка содержит ровно одну команду: ```add K V```, ```set K V```, ```delete K```, ```search K```,```min```
, ```max``` или ```print```, где K - целое число, ключ, V - произвольная строка без пробелов (значение).

## Формат результата

Команда ```add``` добавляет значение V в дерево по ключу K, ```set``` - изменяет данные по ключу, команда ```delete```
удаляет данные.

Команда ```search``` выводит либо "1 V", либо "0", где V - значение для найденного ключа.

Команды ```min``` и ```max``` выводят "K V", где K - минимальный или максимальный ключ дерева соответственно, V -
значение по этому ключу.

Команда ```print``` выводит все дерево целиком. Она не изменяет дерево.

Дерево выводится по уровням, слева направо, 1 строка - 1 уровень. Первая строка содержит только корень дерева в
формате "[K V]" или "_", если дерево пустое.

Каждая последующая строка содержит один уровень дерева. Вершины выводятся в формате "[K V P]", где P - ключ родительской
вершины. Если вершина отсутствует, ставится "_".

Вершины разделены пробелом.

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Пример

| Входные данные| Результатат работы |
| ------------- |:------------------|
| add 8 10      | 0   |
| add 4 14      | 1 15 | 
| add 7 15      | \[4 14]         | 
| set 8 11      | \[3 13 4] \[7 15 4] |
| add 3 13      |_ _ _ \[8 11 7]    |
| add 5 16      |                   |
| search 88     |                   |
| search 7      |                   |
| delete 5      |                   |
| print         |                   |

***

# Непростая куча

Реализуйте двоичную min-кучу. Модифицируйте ее таким образом, чтобы внутреннее ее строение бало таким же, но при этом
доступ по ключу к любому элементу осуществлялся в среднем за константное время.

Реализация самой структуры данных должна быть инкапсулирована, т.е не зависеть от форматов входных/выходных данных и
непосредственно ввода/вывода.

## Формат входных данных

На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Каждая строка содержит ровно одну команду: ```add K V```, ```set K V```, ```delete K```, ```search K```, ```min```
, ```max```, ```extract``` или ```print```, где K - целое число, ключ, V - произвольная строка без пробелов (значение).

## Формат результата

Команда ```add``` добавляет значение V в кучу по ключу K, set - изменяет данные по ключу, команда delete удаляет данные.

Команда ```search``` выводит либо "1 I V", либо "0", где I - индекс, V - значение для найденного ключа

Команды ```min``` и ```max``` выводят "K I V", где K - минимальный или максимальный ключ кучи соответственно, I -
индекс, V - значение по этому ключу.

Команда ```extract``` извлекает корень кучи и выводит "K V", где K, V - ключ и значение извлеченного элемента.

Команда ```print``` выводит всю кучу целиком.

Куча выводится по уровням, слева направо, 1 строка - 1 уровень. Первая строка содержит только корень кучи в
формате "[K V]" или "_", если куча пустая.

Каждая последующая строка содержит один уровень кучи. Вершины выводятся в формате "[K V P]", где P - ключ родительской
вершины. Если вершина отсутствует, ставится "_".

Вершины разделены пробелом.

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Пример

| Входные данные      | Результатат работы |
| ------------- |:------------------|
| add 8 10      | 0   |
| add 4 14      | 1 2 15 | 
| add 7 15      | 3 13         | 
| set 8 11      | \[5 16] |
| add 3 13      | \[8 11 5] \[7 15 5]|
| add 5 16      | \[10 10 8] _ _ _   |
| add 10 10     |                   |
| search 88     |                   |
| search 7      |                   |
| delete 4         |                   |
| extract | |
| print | |

***

# Автокоррекция

Реализуйте программу, которая предлагает варианты замены слова, в котором допущена одна ошибка.

Регистр букв для программы коррекции не имеет значения (слова в словаре хранятся в нижнем регистре).

Варианты ошибок - как в алгоритме Дамерау-Левенштейна: вставка лишнего символа, удаление символа, замена символа или
транспозиция соседних символов.

Реализация алгоритма должна быть инкапсулирована. В комментариях напишите сложность ключевых алгоритмов с пояснениями.

## Формат входных данных

Данные подаются на стандартный поток ввода. Пустые строки игнорируются.

Первая строка содержит число N - количество слов в словаре.

Последующие N строк содержат слова из словаря, по одному в строке.

Остальные строки - слова, которые надо проверять.

## Формат результата

Каждая строка выхода содержит предложение для исправления слов, в порядке их появления.

Если слово не содержит ошибок, то выводится ```%слово% - ok```.

Если слово содержит одну ошибку, то выводится ```%слово% -> %слово_в_словаре%```. Если вариантов несколько, то они
сортируются лексикографически и разделяются запятой с пробелом.

Если слово содержит более одной ошибки, то выводится ```%слово% -?```.

Результат работы программы выводится в стандартный поток вывода.

## Пример

| Входные данные|  Результат работы  |
| ------------- |:------------------|
|8 | some - ok |
|some | randoms -> random |
|random | wards -> words |
|words | seeking -? |
|for | fro -> for |
|testing | solution -> solutions |
|your | fur -> far, for |
|solutions | |
|far | |
| | |
|some | |
|randoms |
|wards | |
|seeking | |
|fro | |
|solution | |
|fur | |
