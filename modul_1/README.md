# Modul_1 содержит 4 программы на тему базовых структур данных

***

# Задача про сумму

На стандартном потоке ввода задаётся последовательность целых чисел.

Каждое число последовательности не меньше -200 000 000 и не больше 200 000 000.

На стандартный поток вывода напечатайте сумму этих чисел.

## Пример

|Входные данные    | Результат работы|
|---|:---|
|1 2 3 4|10|

***

# Задача про стек

Реализуйте стек, используя только массив.

## Формат входных данных

На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.

Первая строка всегда содержит ```set_size N```, где N - максимальный размер стека, целое число.

Каждая последующая строка содержит ровно одну команду: ```push X```, ```pop``` или ```print```, где X - произвольная
строка без пробелов.

## Формат результата

Команда ```print``` выводит содержимое стека (снизу вверх) одной строкой, значения разделяются пробелами. Если стек
пуст, то выводится "empty".

В случае переполнения стека выводится "overflow".

Команда ```pop``` выводит элемент или "underflow", если стек пуст.

Память под стек должна быть выделена не более одного раза, при вызове команды ```set_size```.

В любой непонятной ситуации результатом работы любой команды будет "error".

Результат работы программы выводится в стандартный поток вывода.

## Пример

|Входные данные    | Результат работы|
|---|:---|
|set_size 5|underflow|
|pop|1 2 3 4 5|
|push 1|overflow|
|push 2|5|
|push 3|1 2 3 4 6|
|push 4||
|push 5||
|print||
|push 6||
|pop||
|push 6||
|print||

***

# Задача про очередь

Это как задача про стек, только про очередь.

Реализуйте очередь, используя только массив.

Ввод и вывод данных осуществляется через файлы. Имена входного и выходного файлов задаются через аргументы командной
строки (первый и второй соответственно).

## Формат входных данных

Во входном файле задаётся последовательность команд. Пустые строки игнорируются.

Первая строка всегда содержит ```set_size N```, где N - максимальный размер очереди, целое число.

Каждая последующая строка содержит ровно одну команду: ```push X```, ```pop``` или ```print```, где X - произвольная
строка без пробелов.

## Формат результата

Команда ```print``` выводит содержимое очередь (от головы к хвосту) одной строкой, значения разделяются пробелами. Если
очередь пуста, то выводится "empty".

В случае переполнения очереди выводится "overflow".

Команда ```pop``` выводит элемент или "underflow", если очередь пуста.

Память под очередь должна быть выделена не более одного раза, при вызове команды ```set_size```.

В любой непонятной ситуации результатом работы любой команды будет "error".

## Пример

|Входные данные в файле input    | Результат работы в файле output|
|---|:---|
|set_size 5|underflow|
|pop|1 2 3 4 5|
|push 1|overflow|
|push 2|1|
|push 3|2 3 4 5 6|
|push 4||
|push 5||
|print||
|push 6||
|pop||
|push 6||
|print||

***

# Задача про обход графа

Реализуйте обход графа в ширину и глубину.

Вершины упорядочены в лексикографическом порядке.

## Формат входных данных

Первая строка стандартного потока ввода данных имеет формат ```[graph_type] [start_vertex] [search_type]```, где

- ```[graph_type]``` - тип графа, ориентированный ('d') или неориентированный ('u');
- ```[start_vertex]``` - идентификатор вершины, с которой начинать обход графа;
- ```[search_type]``` - тип обхода, в ширину ('b') или в глубину ('d').

Каждая последующая строка содержит ребро, которое представляет собой идентификаторы начальной и конечной вершины,
разделенные пробелом.

## Формат результата

Результат работы программы выводится в стандартный поток вывода.

Идентификаторы посещенных вершин выводятся по одному в строке в порядке обхода.

## Пример

|Входные данные    | Результат работы|
|---|:---|
|u 1 d|1|
|1 3|2|
|1 2|3|
|1 5|4|
|2 3|5|
|2 4||
|5 4||
